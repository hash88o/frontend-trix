const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const { ethers } = require('ethers');

// Colors for console output
const colors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

// Service configuration
const services = [
    {
        name: 'Backend API',
        command: 'node',
        args: ['api/index.js'],
        cwd: process.cwd(),
        port: 3000,
        color: colors.blue
    },
    {
        name: 'Leaderboard',
        command: 'node',
        args: ['tools/leaderboard.js'],
        cwd: process.cwd(),
        port: 3001,
        color: colors.magenta
    },
    {
        name: 'Matchmaking',
        command: 'node',
        args: ['matchmaking-server.js'],
        cwd: process.cwd(),
        port: 3002,
        color: colors.yellow
    },
    {
        name: 'Frontend',
        command: 'npx',
        args: ['http-server', 'web', '-p', '8080', '--cors'],
        cwd: process.cwd(),
        port: 8080,
        color: colors.cyan
    }
];

let runningServices = [];

function log(service, message, isError = false) {
    const timestamp = new Date().toLocaleTimeString();
    const color = isError ? colors.red : service.color;
    console.log(`${color}[${timestamp}] [${service.name}]${colors.reset} ${message}`);
}

function logSystem(message, isError = false) {
    const timestamp = new Date().toLocaleTimeString();
    const color = isError ? colors.red : colors.green;
    console.log(`${color}[${timestamp}] [SYSTEM]${colors.reset} ${message}`);
}

// Check if .env file exists and has required variables
function checkEnvironment() {
    const envPath = path.join(process.cwd(), '.env');

    if (!fs.existsSync(envPath)) {
        logSystem('âŒ .env file not found! Creating template...', true);
        createEnvTemplate();
        return false;
    }

    const envContent = fs.readFileSync(envPath, 'utf8');
    const requiredVars = [
        'RPC_URL',
        'PRIVATE_KEY',
        'GAMETOKEN_ADDR',
        'TOKENSTORE_ADDR',
        'PLAYGAME_ADDR',
        'MOCKUSDT_ADDR'
    ];

    const missingVars = requiredVars.filter(varName => {
        return !envContent.includes(`${varName}=`) ||
            envContent.match(new RegExp(`${varName}=\\s*$`, 'm'));
    });

    if (missingVars.length > 0) {
        logSystem(`âŒ Missing environment variables: ${missingVars.join(', ')}`, true);
        logSystem('Please update your .env file with the deployed contract addresses', true);
        return false;
    }

    return true;
}

// Create .env template
function createEnvTemplate() {
    const template = `# TriX Gaming Platform Environment Configuration
# Generated by start-all.js script

# ==== BLOCKCHAIN CONFIGURATION ====
RPC_URL=http://127.0.0.1:8545
PRIVATE_KEY=

# ==== CONTRACT ADDRESSES (SET AFTER DEPLOYMENT) ====
GAMETOKEN_ADDR=
TOKENSTORE_ADDR=
PLAYGAME_ADDR=
MOCKUSDT_ADDR=

# ==== API CONFIGURATION ====
PORT=3000
LEADERBOARD_PORT=3001

# ==== TREASURY CONFIGURATION ====
TREASURY_ADDRESS=

# Instructions:
# 1. Deploy contracts using: npm run deploy
# 2. Update the contract addresses above
# 3. Set your private key (without 0x prefix)
# 4. Run: node scripts/start-all.js
`;

    fs.writeFileSync('.env', template);
    logSystem('âœ… Created .env template file');
}

// Check if contracts are deployed
async function checkContracts() {
    try {
        require('dotenv').config();

        const rpcUrl = process.env.RPC_URL || 'http://127.0.0.1:8545';
        const provider = new ethers.JsonRpcProvider(rpcUrl);

        // Check if we can connect to the network
        await provider.getNetwork();
        logSystem('âœ… Connected to blockchain network');

        // Check if contract addresses are valid
        const contracts = {
            'GameToken': process.env.GAMETOKEN_ADDR,
            'TokenStore': process.env.TOKENSTORE_ADDR,
            'PlayGame': process.env.PLAYGAME_ADDR,
            'MockUSDT': process.env.MOCKUSDT_ADDR
        };

        for (const [name, address] of Object.entries(contracts)) {
            if (!address || address === '0x0000000000000000000000000000000000000000') {
                logSystem(`âŒ ${name} address not set in .env`, true);
                return false;
            }

            const code = await provider.getCode(address);
            if (code === '0x') {
                logSystem(`âŒ No contract found at ${name} address: ${address}`, true);
                return false;
            }
        }

        logSystem('âœ… All contracts verified on blockchain');
        return true;
    } catch (error) {
        logSystem(`âŒ Blockchain connection failed: ${error.message}`, true);
        return false;
    }
}

// Generate ABIs for the API
async function generateABIs() {
    try {
        const abiDir = path.join(process.cwd(), 'api', 'abis');

        // Create ABIs directory if it doesn't exist
        if (!fs.existsSync(abiDir)) {
            fs.mkdirSync(abiDir, { recursive: true });
        }

        // Copy ABIs from artifacts if they exist
        const artifactsDir = path.join(process.cwd(), 'artifacts', 'contracts');

        if (fs.existsSync(artifactsDir)) {
            const contracts = ['GameToken.sol', 'TokenStore.sol', 'PlayGame.sol'];

            for (const contractFile of contracts) {
                const contractName = contractFile.replace('.sol', '');
                const artifactPath = path.join(artifactsDir, contractFile, `${contractName}.json`);

                if (fs.existsSync(artifactPath)) {
                    const artifact = JSON.parse(fs.readFileSync(artifactPath, 'utf8'));
                    const abiPath = path.join(abiDir, `${contractName}.json`);
                    fs.writeFileSync(abiPath, JSON.stringify(artifact.abi, null, 2));
                    logSystem(`âœ… Generated ABI for ${contractName}`);
                }
            }
        }

        return true;
    } catch (error) {
        logSystem(`âš ï¸  Failed to generate ABIs: ${error.message}`);
        return false;
    }
}

// Start a service
function startService(service) {
    return new Promise((resolve, reject) => {
        log(service, 'ğŸš€ Starting...');

        const process = spawn(service.command, service.args, {
            cwd: service.cwd,
            stdio: ['pipe', 'pipe', 'pipe'],
            shell: true
        });

        process.stdout.on('data', (data) => {
            const output = data.toString().trim();
            if (output) {
                log(service, output);
            }
        });

        process.stderr.on('data', (data) => {
            const output = data.toString().trim();
            if (output && !output.includes('DeprecationWarning')) {
                log(service, output, true);
            }
        });

        process.on('close', (code) => {
            if (code !== 0) {
                log(service, `âŒ Exited with code ${code}`, true);
            } else {
                log(service, 'âœ… Stopped gracefully');
            }
        });

        process.on('error', (error) => {
            log(service, `âŒ Failed to start: ${error.message}`, true);
            reject(error);
        });

        // Store the process
        service.process = process;
        runningServices.push(service);

        // Wait a bit for the service to start
        setTimeout(() => {
            log(service, `âœ… Started on port ${service.port}`);
            resolve();
        }, 2000);
    });
}

// Stop all services
function stopAllServices() {
    logSystem('ğŸ›‘ Stopping all services...');

    runningServices.forEach(service => {
        if (service.process && !service.process.killed) {
            log(service, 'ğŸ›‘ Stopping...');
            service.process.kill('SIGTERM');
        }
    });

    // Force kill after 5 seconds
    setTimeout(() => {
        runningServices.forEach(service => {
            if (service.process && !service.process.killed) {
                service.process.kill('SIGKILL');
            }
        });
        process.exit(0);
    }, 5000);
}

// Main startup function
async function main() {
    console.log(`${colors.bright}${colors.green}
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘        ğŸ® TriX Gaming Platform         â•‘
â•‘          Service Orchestrator          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${colors.reset}
`);

    // Check environment
    logSystem('ğŸ” Checking environment...');
    if (!checkEnvironment()) {
        logSystem('âŒ Environment check failed. Please configure .env file.', true);
        process.exit(1);
    }

    // Check contracts
    logSystem('ğŸ” Checking blockchain contracts...');
    if (!await checkContracts()) {
        logSystem('âŒ Contract check failed. Please deploy contracts first.', true);
        logSystem('Run: npm run deploy', true);
        process.exit(1);
    }

    // Generate ABIs
    logSystem('ğŸ“ Generating ABIs...');
    await generateABIs();

    // Install dependencies if needed
    const apiPackagePath = path.join(process.cwd(), 'api', 'package.json');
    if (fs.existsSync(apiPackagePath)) {
        const nodeModulesPath = path.join(process.cwd(), 'api', 'node_modules');
        if (!fs.existsSync(nodeModulesPath)) {
            logSystem('ğŸ“¦ Installing API dependencies...');
            try {
                const { execSync } = require('child_process');
                execSync('npm install', { cwd: path.join(process.cwd(), 'api'), stdio: 'inherit' });
                logSystem('âœ… API dependencies installed');
            } catch (error) {
                logSystem('âŒ Failed to install API dependencies', true);
            }
        }
    }

    logSystem('ğŸš€ Starting all services...');

    try {
        // Start services sequentially with delays
        for (const service of services) {
            await startService(service);
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        // Display service URLs
        console.log(`${colors.bright}${colors.green}
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ‰ ALL READY!             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${colors.reset}

ğŸŒ Service URLs:
  â€¢ Frontend:      ${colors.cyan}http://localhost:8080${colors.reset}
  â€¢ Backend API:   ${colors.blue}http://localhost:3000${colors.reset}
  â€¢ Leaderboard:   ${colors.magenta}http://localhost:3001${colors.reset}

ğŸ“Š API Endpoints:
  â€¢ Health:        ${colors.blue}http://localhost:3000/health${colors.reset}
  â€¢ Leaderboard:   ${colors.magenta}http://localhost:3001/leaderboard${colors.reset}
  â€¢ Stats:         ${colors.magenta}http://localhost:3001/stats${colors.reset}

ğŸ® Ready to play! Open ${colors.cyan}http://localhost:8080${colors.reset} in your browser.

${colors.yellow}Press Ctrl+C to stop all services${colors.reset}
`);

    } catch (error) {
        logSystem(`âŒ Failed to start services: ${error.message}`, true);
        stopAllServices();
        process.exit(1);
    }
}

// Handle shutdown
process.on('SIGINT', stopAllServices);
process.on('SIGTERM', stopAllServices);

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
    logSystem(`âŒ Uncaught exception: ${error.message}`, true);
    stopAllServices();
});

process.on('unhandledRejection', (reason) => {
    logSystem(`âŒ Unhandled rejection: ${reason}`, true);
    stopAllServices();
});

// Start the system
main().catch(error => {
    logSystem(`âŒ Startup failed: ${error.message}`, true);
    process.exit(1);
});
